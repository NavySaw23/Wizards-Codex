{% load static %}

<style>
    body {
        margin: 0;
    }

    #canvas {
        position: relative;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
</style>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.min.js"></script>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/",
        "cannon" : "https://unpkg.com/cannon@0.6.2/build/cannon.js"
      }
    }
  </script>

<script type="module">

    // ---Imports----------------------------------------------------------------
    import * as THREE from 'three'
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
    import { FontLoader } from 'three/addons/loaders/FontLoader.js'
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js'
    import * as Cannon from 'cannon'

    // ---Definitions-----------------------------------------------------------

    let scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 10);
    camera.lookAt(0, 0, 0);

    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    let world = new CANNON.World();
    world.gravity.set(0, 0, 0);

    let controls = new OrbitControls(camera, renderer.domElement);
    let isOrbiting = false;
    // controlHelper()

    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    const loader = new GLTFLoader();
    const fontLoader = new FontLoader();


    // ---Models----------------------------------------------------------------

    let groundBody, groundMesh
    let CharacterBody, CharacterMesh, CharacterModel, CharacterSpeed = 20, modelLoaded = false;
    let CharacterVelocity = new CANNON.Vec3(0, 0, 0);
    let ColliderOpacity = 0.0;

    let InteractorMesh_L1, InteractorBody_L1




    // ---Main------------------------------------------------------------------
    function start() {

        //---lighting------------------
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        addGround();
        addCharacter();

        Level1(-2, 0, -30)

        handleCharacterMovement();
    }

    function update() {
        world.step(1 / 60);

        CharacterMesh.position.copy(CharacterBody.position);

        if (!isOrbiting) {
            camera.position.x = CharacterMesh.position.x;
            camera.position.y = CharacterMesh.position.y + 10;
            camera.position.z = CharacterMesh.position.z + 20;
            camera.lookAt(CharacterMesh.position);
        }


        interactions();

        requestAnimationFrame(update);
    }

    function animate() {
        if (modelLoaded) {
            CharacterModel.position.copy(CharacterBody.position);
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    // ---Essential-Functions---------------------------------------------------

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize);

    function checkInteraction() {
        const characterBox = new THREE.Box3().setFromObject(CharacterMesh);
        const levelInteractorBox = new THREE.Box3().setFromObject(InteractorMesh_L1);

        if (characterBox.intersectsBox(levelInteractorBox)) {
            InteractorMesh_L1.material.color.set(0x800080); // Purple
        } else {
            InteractorMesh_L1.material.color.set(0x008000); // Green
        }
    }

    function interactions() {
        // Check for collision between CharacterBody and InteractorBody_L1
        const characterBox = new THREE.Box3().setFromObject(CharacterMesh);
        const interactorBox = new THREE.Box3().setFromObject(InteractorMesh_L1);
        
        if (characterBox.intersectsBox(interactorBox)) {
            InteractorMesh_L1.material.color.set(0x800080); // Purple
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    window.location.href = "/level1";
                }
            });
        } else {
            InteractorMesh_L1.material.color.set(0x008000); // Green
        }
    }



    // ---Movement--------------------------------------------------------------

    function handleCharacterMovement() {
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    CharacterVelocity.z = -CharacterSpeed;
                    CharacterModel.rotation.y = Math.PI; // Face forward

                    break;
                case 'ArrowDown':
                    CharacterVelocity.z = CharacterSpeed;
                    CharacterModel.rotation.y = 0; // Face backward

                    break;
                case 'ArrowLeft':
                    CharacterVelocity.x = -CharacterSpeed;
                    CharacterModel.rotation.y = Math.PI / 2; // Face left

                    break;
                case 'ArrowRight':
                    CharacterVelocity.x = CharacterSpeed;
                    CharacterModel.rotation.y = -Math.PI / 2; // Face right

                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                    CharacterVelocity.z = 0;
                    break;
                case 'ArrowLeft':
                case 'ArrowRight':
                    CharacterVelocity.x = 0;
                    break;
            }
        });

        function updateCharacterVelocity() {
            CharacterBody.velocity.x = CharacterVelocity.x;
            CharacterBody.velocity.z = CharacterVelocity.z;
            CharacterBody.position.y = 1;
            requestAnimationFrame(updateCharacterVelocity);
        }
        updateCharacterVelocity();
    }


    // ---Helper-Functions------------------------------------------------------


    function controlHelper() {


        controls.enablePan = true;

        controls.enableRotate = false;

        controls.enableZoom = true;
        controls.minDistance = 5;
        controls.maxDistance = 30;

    }

    controls.addEventListener('start', () => {
        isOrbiting = true;
    });

    controls.addEventListener('end', () => {
        isOrbiting = false;
    });

    function text(x, y, z, string) {
        const fontLoader = new FontLoader();
        fontLoader.load("{%static 'Magic_School.json'%}", function (font) {
            const textGeometry = new TextGeometry(string, {
                font: font,
                size: 2,
                height: 0.3,
                curveSegments: 12,
            });
            const textMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 1,
                emissive: 0xFFD700,
                emissiveIntensity: 50
            });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(x, y, z);
            scene.add(textMesh);
        }, undefined, function (error) {
            console.error('An error occurred while loading the font:', error);
        });
    }


    // ---Object-Functions------------------------------------------------------

    function addGround() {
        const groundGeometry = new THREE.BoxGeometry(1000, 10, 1000);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x013220 });
        groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.position.set(0, -5, 0); // Move the ground down to the xz plane
        scene.add(groundMesh);

        const groundShape = new CANNON.Box(new CANNON.Vec3(500, 5, 500));
        groundBody = new CANNON.Body({
            mass: 0,
            position: new CANNON.Vec3(0, -5, 0),
            shape: groundShape,
            type: CANNON.Body.STATIC
        });
        world.addBody(groundBody);
    }


    function addCharacter() {
        const CharacterGeometry = new THREE.BoxGeometry(2, 2, 2);
        const CharacterMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: ColliderOpacity });
        CharacterMesh = new THREE.Mesh(CharacterGeometry, CharacterMaterial);
        scene.add(CharacterMesh);

        const CharacterShape = new CANNON.Box(new CANNON.Vec3(1, 1, 1));
        CharacterBody = new CANNON.Body({
            mass: 1, // Give the Character some mass
            position: new CANNON.Vec3(0, 1, 0),
            shape: CharacterShape,
            velocity: new CANNON.Vec3(0, 0, 0)
        });
        world.addBody(CharacterBody);

        loader.load("{%static 'models/robo_toon.glb'%}", function (gltf) {
            CharacterModel = gltf.scene;
            CharacterModel.scale.set(0.2, 0.2, 0.2); // Set the scale of the model
            CharacterModel.position.set(0, 1, 0); // Set the position of the model
            scene.add(CharacterModel); // Add the model to the scene

            modelLoaded = true;
        }, undefined, function (error) {
            console.error('An error occurred while loading the model:', error);
        });

        // Later in your code...
        if (modelLoaded) {
            console.log(CharacterModel.position);
        }
    }

    function addObstacle(x, y, z, rotationYDeg, length, breadth) {
        // Convert rotation from degrees to radians
        const rotationYRad = (rotationYDeg * Math.PI) / 180;

        // Create the Three.js mesh
        const obstacleGeometry = new THREE.BoxGeometry(length, 20, breadth);
        const obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: ColliderOpacity });
        const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
        obstacleMesh.position.set(x, y + 10, z);
        obstacleMesh.rotation.y = rotationYRad;
        scene.add(obstacleMesh);

        // Create the Cannon.js body
        const obstacleShape = new CANNON.Box(new CANNON.Vec3(length / 2, 10, breadth / 2));
        const obstacleBody = new CANNON.Body({
            mass: 0, // Make the box static
            position: new CANNON.Vec3(x, y + 10, z),
            shape: obstacleShape,
            type: CANNON.Body.STATIC // Make the box a static object
        });
        obstacleBody.quaternion.setFromEuler(0, rotationYRad, 0); // Set the rotation
        world.addBody(obstacleBody);
    }



    // ---Level-Setups------------------------------------------------------

    function Level1(x, y, z) {
        loader.load("{%static 'models/garden.glb'%}", function (gltf) {
            const gardenModel = gltf.scene;
            gardenModel.scale.set(1, 1, 1); // Set the scale of the model
            gardenModel.position.set(x, y, z); // Set the position of the model
            scene.add(gardenModel); // Add the model to the scene
        }, undefined, function (error) {
            console.error('An error occurred while loading the model:', error);
        });


        // fences
        addObstacle(2 + x, 0 + y, -20 + z, 0, 26, 0.5);
        addObstacle(-17 + x, 0 + y, -9 + z, 60, 26, 0.5);
        addObstacle(20 + x, 0 + y, -9 + z, -60, 26, 0.5);
        addObstacle(-17 + x, 0 + y, 10 + z, -60, 26, 0.5);
        addObstacle(20 + x, 0 + y, 10 + z, 60, 26, 0.5);
        addObstacle(9.5 + x, 0 + y, 21.5 + z, 0, 8, 0.5);
        addObstacle(-6 + x, 0 + y, 21.5 + z, 0, 8, 0.5);

        // trees
        addObstacle(15 + x, 0 + y, 9 + z, 0, 1, 1);
        addObstacle(-14 + x, 0 + y, -2.5 + z, 0, 1, 1);
        addObstacle(-7.5 + x, 0 + y, -14 + z, 0, 1, 1);
        addObstacle(11 + x, 0 + y, -14 + z, 0, 5, 5);

        // interactor
        const InteractorShape_L1 = new THREE.CylinderGeometry(15, 15, 0.2, 6); // Interactor_L1al shape
        const Interactor_L1Material = new THREE.MeshStandardMaterial({ color: 0x008000, transparent: true, opacity: 0.5 });
        InteractorMesh_L1 = new THREE.Mesh(InteractorShape_L1, Interactor_L1Material);
        InteractorMesh_L1.rotation.y = Math.PI / 2; // Rotate to lie flat on the ground
        InteractorMesh_L1.position.set(x + 1.5, y - 0.15, z); // Position the zones as needed
        const Hexsize = 1.65;

        InteractorMesh_L1.scale.set(Hexsize, Hexsize, Hexsize);
        scene.add(InteractorMesh_L1);

        // title
        text(-12, 10, -16, "Chapter 1 - Data Collection");

    }


    start();
    update();
    animate();
</script>