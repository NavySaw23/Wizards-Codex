{% load static %}

<style>
    body {
        margin: 0;
    }

    #canvas {
        position: relative;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
</style>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.min.js"></script>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/",
        "cannon" : "https://unpkg.com/cannon@0.6.2/build/cannon.js"
      }
    }
  </script>

<script type="module">

    let debugmode = false;
    let orthomode = false;
    // debugmode = true;
    // orthomode = true;

    // ---Imports----------------------------------------------------------------
    import * as THREE from 'three'
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
    import { FontLoader } from 'three/addons/loaders/FontLoader.js'
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js'
    import * as Cannon from 'cannon'

    // ---Definitions-----------------------------------------------------------

    let scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 500, 0);
    camera.lookAt(0, 0, 0);

    if (orthomode) {
        camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.1, 1000);
        camera.position.set(0, 500, 0);
        camera.lookAt(0, 0, 0);
    }

    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    let world = new CANNON.World();
    world.gravity.set(0, 0, 0);

    let controls = new OrbitControls(camera, renderer.domElement);
    let isOrbiting = false;
    // controlHelper()

    const axesHelper = new THREE.AxesHelper(5);
    // scene.add(axesHelper);

    const loader = new GLTFLoader();
    const fontLoader = new FontLoader();


    // ---Models----------------------------------------------------------------

    let groundBody, groundMesh
    let CharacterBody, CharacterMesh, CharacterModel, CharacterSpeed = 20, modelLoaded = false;
    let CharacterVelocity = new CANNON.Vec3(0, 0, 0);
    let ColliderOpacity = 0;

    let InteractorMesh_L1, InteractorBody_L1
    let InteractorMesh_L2, InteractorBody_L2



    if (debugmode) {
        ColliderOpacity = 0.8;
    }
    else {

    }



    // ---Main------------------------------------------------------------------
    function start() {

        //---lighting------------------
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        addGround();
        addCharacter();

        Level1(-2, 0, -30)
        Level2(150, -1, -80)


        handleCharacterMovement();
    }

    function update() {
        world.step(1 / 60);

        CharacterMesh.position.copy(CharacterBody.position);

        if (!isOrbiting && !debugmode) {
            camera.position.x = CharacterMesh.position.x;
            camera.position.y = CharacterMesh.position.y + 5;
            camera.position.z = CharacterMesh.position.z + 20;
            camera.lookAt(CharacterMesh.position);
            camera.position.y += 10;
        }


        interactions();

        requestAnimationFrame(update);
    }

    function animate() {
        if (modelLoaded) {
            CharacterModel.position.copy(CharacterBody.position);
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    // ---Essential-Functions---------------------------------------------------

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize);

    function checkInteraction() {
        const characterBox = new THREE.Box3().setFromObject(CharacterMesh);
        const levelInteractorBox = new THREE.Box3().setFromObject(InteractorMesh_L1);

        if (characterBox.intersectsBox(levelInteractorBox)) {
            InteractorMesh_L1.material.color.set(0x800080); // Purple
        } else {
            InteractorMesh_L1.material.color.set(0x008000); // Green
        }
    }

    function interactions() {
        // Check for collision between CharacterBody and InteractorBody_L1
        const characterBox = new THREE.Box3().setFromObject(CharacterMesh);
        const interactorBox_L1 = new THREE.Box3().setFromObject(InteractorMesh_L1);
        const interactorBox_L2 = new THREE.Box3().setFromObject(InteractorMesh_L2);

        if (characterBox.intersectsBox(interactorBox_L1)) {
            InteractorMesh_L1.material.color.set(0x790deb);
            InteractorMesh_L1.material.emissive.set(0x790deb);
            InteractorMesh_L1.material.emissiveIntensity = 5;
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    window.location.href = "/level1";
                }
            });
        } else {
            InteractorMesh_L1.material.color.set(0x008000);
            InteractorMesh_L1.material.emissive.set(0x790deb00);
            InteractorMesh_L1.material.emissiveIntensity = 0;
        }

        if (characterBox.intersectsBox(interactorBox_L2)) {
            InteractorMesh_L2.material.color.set(0x790deb);
            InteractorMesh_L2.material.emissive.set(0x790deb);
            InteractorMesh_L2.material.emissiveIntensity = 5;
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    window.location.href = "/level2";
                }
            });
        } else {
            InteractorMesh_L2.material.color.set(0x008000);
            InteractorMesh_L2.material.emissive.set(0x790deb00);
            InteractorMesh_L2.material.emissiveIntensity = 0;
        }
    }



    // ---Movement--------------------------------------------------------------

    function handleCharacterMovement() {
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    CharacterVelocity.z = -CharacterSpeed;
                    CharacterModel.rotation.y = Math.PI; // Face forward

                    break;
                case 'ArrowDown':
                    CharacterVelocity.z = CharacterSpeed;
                    CharacterModel.rotation.y = 0; // Face backward

                    break;
                case 'ArrowLeft':
                    CharacterVelocity.x = -CharacterSpeed;
                    CharacterModel.rotation.y = Math.PI / 2; // Face left

                    break;
                case 'ArrowRight':
                    CharacterVelocity.x = CharacterSpeed;
                    CharacterModel.rotation.y = -Math.PI / 2; // Face right

                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                    CharacterVelocity.z = 0;
                    break;
                case 'ArrowLeft':
                case 'ArrowRight':
                    CharacterVelocity.x = 0;
                    break;
            }
        });

        function updateCharacterVelocity() {
            CharacterBody.velocity.x = CharacterVelocity.x;
            CharacterBody.velocity.z = CharacterVelocity.z;
            CharacterBody.position.y = 1;
            requestAnimationFrame(updateCharacterVelocity);
        }
        updateCharacterVelocity();
    }

    // ---Helper-Functions------------------------------------------------------

    function controlHelper() {


        controls.enablePan = true;

        controls.enableRotate = false;

        controls.enableZoom = true;
        controls.minDistance = 5;
        controls.maxDistance = 30;

    }

    controls.addEventListener('start', () => {
        isOrbiting = true;
    });

    controls.addEventListener('end', () => {
        isOrbiting = false;
    });

    function text(x, y, z, string, size) {
        const fontLoader = new FontLoader();
        fontLoader.load("{%static 'Magic_School.json'%}", function (font) {
            const textGeometry = new TextGeometry(string, {
                font: font,
                size: size,
                height: 0.3,
                curveSegments: 12,
            });
            const textMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 1,
                emissive: 0xFFD700,
                emissiveIntensity: 50
            });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(x, y, z);
            scene.add(textMesh);
        }, undefined, function (error) {
            console.error('An error occurred while loading the font:', error);
        });
    }


    // ---Object-Functions------------------------------------------------------

    function addGround() {
        const groundGeometry = new THREE.BoxGeometry(1000, 10, 1000);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x013220 });
        groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.position.set(0, -5, 0); // Move the ground down to the xz plane
        scene.add(groundMesh);

        const groundShape = new CANNON.Box(new CANNON.Vec3(500, 5, 500));
        groundBody = new CANNON.Body({
            mass: 0,
            position: new CANNON.Vec3(0, -5, 0),
            shape: groundShape,
            type: CANNON.Body.STATIC
        });
        world.addBody(groundBody);
    }

    function addCharacter() {
        const CharacterGeometry = new THREE.BoxGeometry(2, 2, 2);
        const CharacterMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: ColliderOpacity });
        CharacterMesh = new THREE.Mesh(CharacterGeometry, CharacterMaterial);
        if (debugmode) {
            scene.add(CharacterMesh);
        }

        const CharacterShape = new CANNON.Box(new CANNON.Vec3(1, 1, 1));
        CharacterBody = new CANNON.Body({
            mass: 1, // Give the Character some mass
            position: new CANNON.Vec3(0, 1, 0),
            shape: CharacterShape,
            velocity: new CANNON.Vec3(0, 0, 0)
        });
        world.addBody(CharacterBody);

        loader.load("{%static 'models/robo_toon.glb'%}", function (gltf) {
            CharacterModel = gltf.scene;
            CharacterModel.scale.set(0.2, 0.2, 0.2); // Set the scale of the model
            CharacterModel.position.set(0, 1, 0); // Set the position of the model
            scene.add(CharacterModel); // Add the model to the scene

            modelLoaded = true;
        }, undefined, function (error) {
            console.error('An error occurred while loading the model:', error);
        });

        // Later in your code...
        if (modelLoaded) {
            console.log(CharacterModel.position);
        }
    }

    function addObstacle(x, y, z, rotationYDeg, length, breadth) {
        // Convert rotation from degrees to radians
        const rotationYRad = (rotationYDeg * Math.PI) / 180;

        if (debugmode) {
            // Create the Three.js mesh
            const obstacleGeometry = new THREE.BoxGeometry(length, 20, breadth);
            const obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: ColliderOpacity });
            const obstacleMesh = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacleMesh.position.set(x, y + 10, z);
            obstacleMesh.rotation.y = rotationYRad;
            scene.add(obstacleMesh);
        }

        // Create the Cannon.js body
        const obstacleShape = new CANNON.Box(new CANNON.Vec3(length / 2, 10, breadth / 2));
        const obstacleBody = new CANNON.Body({
            mass: 0, // Make the box static
            position: new CANNON.Vec3(x, y + 10, z),
            shape: obstacleShape,
            type: CANNON.Body.STATIC // Make the box a static object
        });
        obstacleBody.quaternion.setFromEuler(0, rotationYRad, 0); // Set the rotation
        world.addBody(obstacleBody);
    }



    // ---Level-Setups------------------------------------------------------

    function Level1(x, y, z) {
        loader.load("{%static 'models/garden.glb'%}", function (gltf) {
            const gardenModel = gltf.scene;
            gardenModel.scale.set(1, 1, 1); // Set the scale of the model
            gardenModel.position.set(x, y, z); // Set the position of the model
            scene.add(gardenModel); // Add the model to the scene
        }, undefined, function (error) {
            console.error('An error occurred while loading the model:', error);
        });


        // fences
        addObstacle(2 + x, 0 + y, -20 + z, 0, 26, 0.5);
        addObstacle(-17 + x, 0 + y, -9 + z, 60, 26, 0.5);
        addObstacle(20 + x, 0 + y, -9 + z, -60, 26, 0.5);
        addObstacle(-17 + x, 0 + y, 10 + z, -60, 26, 0.5);
        addObstacle(20 + x, 0 + y, 10 + z, 60, 26, 0.5);
        addObstacle(9.5 + x, 0 + y, 21.5 + z, 0, 8, 0.5);
        addObstacle(-6 + x, 0 + y, 21.5 + z, 0, 8, 0.5);

        // trees
        addObstacle(15 + x, 0 + y, 9 + z, 0, 1, 1);
        addObstacle(-14 + x, 0 + y, -2.5 + z, 0, 1, 1);
        addObstacle(-7.5 + x, 0 + y, -14 + z, 0, 1, 1);
        addObstacle(11 + x, 0 + y, -14 + z, 0, 5, 5);

        // interactor
        const InteractorShape_L1 = new THREE.CylinderGeometry(15, 15, 0.2, 6); // Interactor_L1al shape
        const Interactor_L1Material = new THREE.MeshStandardMaterial({ color: 0x008000, transparent: true, opacity: 0.5 });
        InteractorMesh_L1 = new THREE.Mesh(InteractorShape_L1, Interactor_L1Material);
        InteractorMesh_L1.rotation.y = Math.PI / 2; // Rotate to lie flat on the ground
        InteractorMesh_L1.position.set(x + 1.5, y - 0.15, z); // Position the InteractorMesh_L1s as needed
        const Hexsize = 1.65;

        InteractorMesh_L1.scale.set(Hexsize, Hexsize, Hexsize);
        scene.add(InteractorMesh_L1);

        // title
        text(-12, 10, -16, "Chapter 1 - Data Collection", 2);
        text(7, 4, -42, "5", 1);

    }

    function Level2(x, y, z) {
        loader.load("{%static 'models/school.glb'%}", function (gltf) {
            const gardenModel = gltf.scene;
            gardenModel.scale.set(1, 1, 1);
            gardenModel.position.set(x, y, z);
            gardenModel.traverse((child) => {
                if (child.isMesh) {
                    child.material.opacity = 1;
                    if (debugmode) {
                        child.material.opacity = 0.5;
                    }
                    child.material.transparent = true;
                }
            });
            scene.add(gardenModel);
        }, undefined, function (error) {
            console.error('An error occurred while loading the model:', error);
        });


        //colliders
        // addObstacle(LR, UD, FB, rotationYDeg, s_lr, s_fb)  
        addObstacle(27 + x, 0 + y, -65 + z, 0, 150, 50);
        addObstacle(100 + x, 0 + y, -15 + z, 0, 40, 50);
        addObstacle(80 + x, 0 + y, 30 + z, 55, 50, 20);
        addObstacle(58 + x, 0 + y, 50 + z, 15, 35, 20);
        addObstacle(18 + x, 0 + y, 47 + z, 12, 40, 20);
        addObstacle(-12 + x, 0 + y, 52 + z, -10, 25, 20);
        addObstacle(-40 + x, 0 + y, 42 + z, -10, 35, 20);
        addObstacle(-70 + x, 0 + y, 28 + z, 2, 45, 20);
        addObstacle(-100 + x, 0 + y, 20 + z, -20, 40, 20);
        addObstacle(-95 + x, 0 + y, 0 + z, 5, 80, 25);
        addObstacle(-80 + x, 0 + y, -20 + z, 4, 60, 25);
        addObstacle(-45 + x, 0 + y, -35 + z, 4, 20, 20);

        addObstacle(-130 + x, 0 + y, 18 + z, 4, 20, 20);
        addObstacle(100 + x, 0 + y, 15 + z, 35, 20, 20);
        addObstacle(-2 + x, 0 + y, 55 + z, 45, 20, 20);



        // interactor
        const InteractorShape_L2 = new THREE.CylinderGeometry(15, 15, 0.2, 6); // 
        const Interactor_L2Material = new THREE.MeshStandardMaterial({ color: 0x008000, transparent: true, opacity: 0.5 });
        InteractorMesh_L2 = new THREE.Mesh(InteractorShape_L2, Interactor_L2Material);
        InteractorMesh_L2.rotation.y = Math.PI / 2; // Rotate to lie flat on the ground
        // InteractorMesh_L2.rotation.z = Math.PI / 2;
        InteractorMesh_L2.position.set(x - 100, y + 1.15, z + 20); // Position the InteractorMesh_L1s as needed
        const Hexsize = 2.65;

        InteractorMesh_L2.scale.set(Hexsize, Hexsize, Hexsize);
        scene.add(InteractorMesh_L2);

        // title
        // text(-12, 10, -16, "Chapter 1 - Data Collection", 2);

    }

    start();
    update();
    animate();

</script>