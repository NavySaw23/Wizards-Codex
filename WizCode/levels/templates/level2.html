{% load static %}

<style>
    body {
        margin: 0;
    }

    #canvas {
        position: relative;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
</style>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.min.js"></script>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/",
        "cannon" : "https://unpkg.com/cannon@0.6.2/build/cannon.js"
      }
    }
  </script>

<script type="module">

    let debugmode = false;
    let orthomode = false;
    // debugmode = true;
    // orthomode = true;

    // ---Imports----------------------------------------------------------------
    import * as THREE from 'three'
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
    import { FontLoader } from 'three/addons/loaders/FontLoader.js'
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js'
    import * as Cannon from 'cannon'

    // ---Definitions-----------------------------------------------------------

    let scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 500, 0);
    camera.lookAt(0, 0, 0);

    if (orthomode) {
        camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.1, 1000);
        camera.position.set(0, 500, 0);
        camera.lookAt(0, 0, 0);
    }

    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    let world = new CANNON.World();
    world.gravity.set(0, 0, 0);

    let controls = new OrbitControls(camera, renderer.domElement);
    let isOrbiting = false;
    const axesHelper = new THREE.AxesHelper(5);
    if(debugmode){
        scene.add(axesHelper);
        controlHelper()
    }


    const loader = new GLTFLoader();
    const fontLoader = new FontLoader();


    // ---Models----------------------------------------------------------------

    let ColliderOpacity = 0;

    if (debugmode) {
        ColliderOpacity = 0.8;
    }
    else {

    }

    // ---Main------------------------------------------------------------------
    function start() {

        //---lighting------------------
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        handleCharacterMovement();
    }

    function update() {
        world.step(1 / 60);

        CharacterMesh.position.copy(CharacterBody.position);
        interactions();

        requestAnimationFrame(update);
    }

    function animate() {
        if (modelLoaded) {
            CharacterModel.position.copy(CharacterBody.position);
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    // ---Essential-Functions---------------------------------------------------

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize);

    function interactions() {
        // For every interaction
        const characterBox = new THREE.Box3().setFromObject(CharacterMesh);
        const interactorBox = new THREE.Box3().setFromObject(InteractorMesh);

        if (characterBox.intersectsBox(interactorBox)) {
            
        } else {
            
        }
    }



    // ---Movement--------------------------------------------------------------

    function handleCharacterMovement() {
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    CharacterVelocity.z = -CharacterSpeed;
                    CharacterModel.rotation.y = Math.PI; // Face forward

                    break;
                case 'ArrowDown':
                    CharacterVelocity.z = CharacterSpeed;
                    CharacterModel.rotation.y = 0; // Face backward

                    break;
                case 'ArrowLeft':
                    CharacterVelocity.x = -CharacterSpeed;
                    CharacterModel.rotation.y = Math.PI / 2; // Face left

                    break;
                case 'ArrowRight':
                    CharacterVelocity.x = CharacterSpeed;
                    CharacterModel.rotation.y = -Math.PI / 2; // Face right

                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                    CharacterVelocity.z = 0;
                    break;
                case 'ArrowLeft':
                case 'ArrowRight':
                    CharacterVelocity.x = 0;
                    break;
            }
        });

        function updateCharacterVelocity() {
            CharacterBody.velocity.x = CharacterVelocity.x;
            CharacterBody.velocity.z = CharacterVelocity.z;
            CharacterBody.position.y = 1;
            requestAnimationFrame(updateCharacterVelocity);
        }
        updateCharacterVelocity();
    }

    // ---Helper-Functions------------------------------------------------------

    function controlHelper() {
        controls.enablePan = true;
        controls.enableRotate = false;
        controls.enableZoom = true;
        controls.minDistance = 5;
        controls.maxDistance = 30;
    }

    controls.addEventListener('start', () => {
        isOrbiting = true;
    });

    controls.addEventListener('end', () => {
        isOrbiting = false;
    });

    function text(x, y, z, string, size) {
        const fontLoader = new FontLoader();
        fontLoader.load("{%static 'Magic_School.json'%}", function (font) {
            const textGeometry = new TextGeometry(string, {
                font: font,
                size: size,
                height: 0.3,
                curveSegments: 12,
            });
            const textMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 1,
                emissive: 0xFFD700,
                emissiveIntensity: 50
            });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(x, y, z);
            scene.add(textMesh);
        }, undefined, function (error) {
            console.error('An error occurred while loading the font:', error);
        });
    }


    // ---Object-Functions------------------------------------------------------

    function addCharacter() {
 
    }

    start();
    update();
    animate();

</script>